{
    "collab_server" : "",
    "contents" : "#***************** projection pursuit regression ***********************#\n#******** Date: April 15th 2016  |  Author: Chen Daijun ****************#\n#******** Project: Projection Pursuit Regression in DACE ***************#\n#******** Part one: Basic Projection pursuit regression  ***************#\n#******** Version : 0.0.0 **********************************************#\n#'Functions build for estimating a given non-parametric model\n#'@include estimate_parametric_function.R\n#************** sub-function: estimate the parametric parts ************#\n\n#------------------ Using quasi-Newton method to solve -----------------#\n#------------------ need responses and their derivates -----------------#\n\n#----------- calculate the derivate of the local linear ----------------#\n#--------------------- Second order Gaussian kernel---------------------#\n#'2-order Gaussian kernel function\n#'\n#'@export\nGaussian_2 <- function(center, scatter_point, brand_width){\n  x <- center\n  x_i <- scatter_point\n  h <- brand_width\n  w <- 1 / sqrt(2 * pi) * exp(- 0.5 * ((x - as.vector(x_i)) / h) ^ 2)\n  return(w)\n}\n#-----------------------------------------------------------------------#\n#'the derivate of 2-order Gaussian kernel function\n#'\n#'@export\n#--------------------- derivates of 2-order Gaussian kernel ------------#\nderivate_Gaussian_2 <- function(center, scatter_point, brand_width){\n  x <- as.vector(center)\n  x_i <- scatter_point\n  h <- brand_width\n  der_Gaussian_2 <- 1 / sqrt(2 * pi) * exp(- 1 / 2 * (x - x_i) ^ 2 / h ^ 2) *\n    (x_i - x) / h\n  return(der_Gaussian_2)\n}\n#-----------------------------------------------------------------------#\n\n#'S_1 function is a part of the derivate of local linear regression function\n#'\n#'@export\n#---------------------- S_1() function: part of derivate ----------------#\nS_1 <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- center\n  x_i <- sample_points\n  s1_x <- sum(1 / h * Gaussian_2(x, x_i, h) * (x - as.vector(x_i)))\n  return(s1_x)\n}\n#-----------------------------------------------------------------------#\n\n#' derivate_S1 function is the derivate of S_1 function\n#'\n#' @export\n#---------------- derivate_S1 function: derivate of S_1() --------------#\nderivate_S1 <- function(center, sample_points, brand_width){\n  x <- as.vector(center)\n  x_i <- sample_points\n  h <- brand_width\n  der_S1 <- sum(1 / h * derivate_Gaussian_2(x, x_i, h) * (x - x_i) +\n                  1 / h * Gaussian_2(x , x_i, h))\n  return(der_S1)\n}\n\n\n\n#-----------------------------------------------------------------------#\n#' S_2 funciton is another part of the derivate of the local linear regression function\n#'\n#'  @export\n#---------------------- S_2() function: part of derivate ---------------#\nS_2 <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- as.vector(sample_points)\n  s2_x <- sum(1 / h * Gaussian_2(x, x_i, h) * (x - x_i) ^ 2)\n  return(s2_x)\n}\n#-----------------------------------------------------------------------#\n#' derivate_S2 is the derivate of S_2 function\n#'\n#' @export\n#--------------- derivate_S2 function: derivate of S_2() ---------------#\nderivate_S2 <- function(center, sample_points, brand_width){\n  x <- center\n  x_i <- sample_points\n  h <- brand_width\n  der_S2 <- sum(1 / h * derivate_Gaussian_2(x, x_i, h) * (x - x_i) ^ 2 +\n                  2 / h * Gaussian_2(x, x_i, h) * (x - x_i))\n  return(der_S2)\n}\n#-----------------------------------------------------------------------#\n#'function named a() is the main part of the derivate of local linear regression. g_hat'(x) = sum(a(X,h)*Y)/sum(a(X,h))\n#'\n#'@export\n#---------------------- a: function ------------------------------------#\na <- function(center, sample_points, brand_width){\n  x <- center\n  x_i <- as.vector(sample_points)\n  h <- brand_width\n  a <- 1 / h * Gaussian_2(x, x_i, h) * (1 - S_1(x, x_i, h) / S_2(x, x_i, h) *\n                                          (x - x_i))\n  return(a)\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- derivative_a() ---------------------------------#\n#' derivate_a function is the derivate of the function a\n#'\n#' @export\nderivate_a <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- sample_points\n  der_a <- 1 / h * derivate_Gaussian_2(x, x_i, h) *\n    (1 - S_1(x , x_i, h) / S_2(x, x_i, h) * (x - x_i))\n  + 1 / h * Gaussian_2(x, x_i, h) * (- derivate_S1(x, x_i, h) / S_2(x, x_i, h)\n                                     + S_1(x, x_i, h) / (S_2(x, x_i, h)^2)\n                                     * derivate_S2(x, x_i, h) * (x - x_i)\n                                     - S_1(x, x_i, h)/ S_2(x, x_i, h))\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- The derivate of S ------------------------------#\n#' S_derivate function is the derivate of the function S()\n#'\n#' @export\nS_derivate <- function(center, sample_points, brand_width, response){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- sample_points\n  y <- response\n  a <- a(x, x_i, h)\n  der_S <- (sum(derivate_a(x, x_i, h) * y) * sum(a) - sum(a * y) *\n              sum(derivate_a(x, x_i, h))) / sum(a ^ 2)\n  return(der_S)\n}\n#-----------------------------------------------------------------------#\n\n#***********************************************************************#\n\n#************* Step 5: Estimating the projection direction *************#\n\n#---------------- function : find the new projection direction ---------#\n#'new_projected_dir is the function which input residuals, design_matrix,\n#' old projected direction and non_parametric model to output the new\n#' direction generated by the quasi-Newton algorithm.\n#'\n#'  @export\nnew_projected_dir <- function(residuals, design_matrix, old_projected_dir,\n                              np_model){\n  res <- residuals\n  design_matrix <- design_matrix\n  dir_old <- old_projected_dir\n  res_pred <- predict(np_model, # the np_model is fixed\n                      newdata = as.data.frame(design_matrix %*% dir_old))\n  h <- np_model$bw # np_model gives the band width automatically\n  res_pred_der <- matrix(rep(0, nrow(design_matrix)), ncol = 1)\n  for(i in 1:nrow(design_matrix)){\n    res_pred_der[i, 1] <- S_derivate(design_matrix[i, ] %*% dir_old,\n                                     design_matrix %*% dir_old, h, res) #key point\n  }\n  weight_reg_response <- design_matrix %*% as.matrix(dir_old) +\n    (res - res_pred)/res_pred_der\n  weight <- (res_pred_der) ^ 2\n\n  design_matrix <- design_matrix\n\n  weight_lm_model <- lm(weight_reg_response ~ 0 + design_matrix, weights = weight)\n\n  dir_new <- matrix(unname(weight_lm_model$coefficients), ncol = 1)\n  return(dir_new)\n}\n#----------------------------------------------------------------------#\n\n#**********************************************************************#\n\n#************** Step 6: iterating the direction to converge ***********#\n\n#----------- inf_norm: measure the distance between two vectors -------#\n#'inf_norm function can return the infinite norm of a finite-dimensional\n#'vector. That is inf_norm return the maximum value of the absolute value of\n#'all vector's components\n#'\n#'@export\ninf_norm <- function(vec_1, vec_2){\n  max_elem <- max(abs(vec_1 - vec_2))\n  return(max_elem)\n}\n#----------------------------------------------------------------------#\n\n#---- projection_dir_final function: converge the projection_dir ------#\n#'projection_dir_final function can obtain a final convergencing projection\n#'direction after we input the residuals, design matrix, initial projected\n#'direction and the criterion value (epslon) for a given non-parametric\n#'regression model\n#'\n#'@export\nprojection_dir_final <- function(residuals, design_matrix,\n                                 initial_projected_dir, epslon){\n  res <- residuals\n  old_dir <- initial_projected_dir\n  design_matrix <- design_matrix\n  epslon <- epslon\n  S <- S(old_dir, res, design_matrix)\n  new_dir <- new_projected_dir(res, design_matrix, old_dir, S)\n  while(inf_norm(old_dir, new_dir) > epslon){\n    old_dir <- new_dir\n    new_dir <- new_projected_dir(res, design_matrix, old_dir, S)\n  }\n  return(new_dir)\n}\n#----------------------------------------------------------------------#\n\n#**********************************************************************#\n",
    "created" : 1461543920643.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2874925166",
    "id" : "B253C00E",
    "lastKnownWriteTime" : 1461578217,
    "last_content_update" : 1461578217282,
    "path" : "~/R/R Codes/Project_PPInterpolator/PPInterpolator/R/estimate_parametric_function.R",
    "project_path" : "R/estimate_parametric_function.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}