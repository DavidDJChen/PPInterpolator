{
    "collab_server" : "",
    "contents" : "#***************** projection pursuit regression ***********************#\n#******** Date: April 15th 2016  |  Author: Chen Daijun ****************#\n#******** Project: Projection Pursuit Regression in DACE ***************#\n#******** Part one: Basic Projection pursuit regression  ***************#\n#******** Version : 0.0.0 **********************************************#\n\n\n#**************** step 1: centerize the response ***********************#\n\ncenterize <- function(response, design_matrix){\n  Y <- response   # initial response\n  X <- design_matrix #\n  all_one_mat <- matrix(rep(1, (nrow(X))^2), nrow = nrow(X))\n  X_centered <- X - 1/nrow(X)* all_one_mat %*% X\n  cent_outcome <- list(cent_resp = Y, cent_design = X_centered)\n  return(cent_outcome)  # centerizing formula: Y - mean(Y)\n} # return a vector\n\n#***********************************************************************#\n\n#**************** step 2: initializaion ********************************#\n\ninitial <- function(centered_resp){ # input centered response\n  res <- centered_resp # initialize residuals\n  M <- 0               # initialize counter\n  initial_outcome <- list(residuals = res, counter = M)# output as a list\n  return(initial_outcome)\n}\n\n#***********************************************************************#\n\n#**************** step 3: calculate the figure_of_merit ****************#\n#************************** criterion of fit ***************************#\n\nfigure_of_merit <- function(residuals, fit_values_alpha){\n  fig_of_mer <- 1 - sum((r - fit_values_alpha)^2) / (sum( r^2 ))\n  return(fig_of_mer) # inputs: residuals and fitted values\n}\n\n#***********************************************************************#\n\n#**************** step 4: univariate smoothing *************************#\n\n#****************** Method 1: fixed S(x) *******************************#\n#******************** Using sigmodi function ***************************#\n\nsigmoid <- function(z){\n  sig_moid <- 1/(1 + exp(-z))\n  return(sig_moid)\n}\n\n#***********************************************************************#\n\n#***************** Method 2: local linear regression *******************#\n#********************* Using packages: np + cubature *******************#\n\n# calculate the local linear response\n#-----------------------------------------------------------------------#\nS <- function(projection_dir, residuals, design_matrix){\n  library(\"np\")\n  res <- residuals\n  projected <-  as.matrix(design_matrix %*% as.matrix(projection_dir))\n  projected <- as.vector(projected)\n  model.np_ll <- npreg(res ~ projected, regtype = \"ll\", bwmethod = \"cv.aic\",\n                       gradients = TRUE)\n  return(model.np_ll)\n}\n#-----------------------------------------------------------------------#\n\n#----------- calculate the derivate of the local linear ----------------#\n#--------------------- Second order Gaussian kernel---------------------#\nGaussian_2 <- function(center, scatter_point, brand_width){\n  x <- center\n  x_i <- scatter_point\n  h <- brand_width\n  w <- 1 / sqrt(2 * pi) * exp(- 0.5 * ((x - as.vector(x_i)) / h) ^ 2)\n  return(w)\n}\n#-----------------------------------------------------------------------#\n\n#--------------------- derivates of 2-order Gaussian kernel ------------#\nderivate_Gaussian_2 <- function(center, scatter_point, brand_width){\n  x <- as.vector(center)\n  x_i <- scatter_point\n  h <- brand_width\n  der_Gaussian_2 <- 1 / sqrt(2 * pi) * exp(- 1 / 2 * (x - x_i) ^ 2 / h ^ 2) *\n    (x_i - x) / h\n  return(der_Gaussian_2)\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- S_1() function: part of derivate ----------------#\nS_1 <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- center\n  x_i <- sample_points\n  s1_x <- sum(1 / h * Gaussian_2(x, x_i, h) * (x - as.vector(x_i)))\n  return(s1_x)\n}\n#-----------------------------------------------------------------------#\n\n#---------------- derivate_S1 function: derivate of S_1() --------------#\nderivate_S1 <- function(center, sample_points, brand_width){\n  x <- as.vector(center)\n  x_i <- sample_points\n  h <- brand_width\n  der_S1 <- sum(1 / h * derivate_Gaussian_2(x, x_i, h) * (x - x_i) +\n                  1 / h * Gaussian_2(x , x_i, h))\n  return(der_S1)\n}\n\n\n\n#-----------------------------------------------------------------------#\n\n#---------------------- S_2() function: part of derivate ---------------#\nS_2 <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- as.vector(sample_points)\n  s2_x <- sum(1 / h * Gaussian_2(x, x_i, h) * (x - x_i) ^ 2)\n  return(s2_x)\n}\n#-----------------------------------------------------------------------#\n\n#--------------- derivate_S2 function: derivate of S_2() ---------------#\nderivate_S2 <- function(center, sample_points, brand_width){\n  x <- center\n  x_i <- sample_points\n  h <- brand_width\n  der_S2 <- sum(1 / h * derivate_Gaussian_2(x, x_i, h) * (x - x_i) ^ 2 +\n                  2 / h * Gaussian_2(x, x_i, h) * (x - x_i))\n  return(der_S2)\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- a: function ------------------------------------#\na <- function(center, sample_points, brand_width){\n  x <- center\n  x_i <- as.vector(sample_points)\n  h <- brand_width\n  a <- 1 / h * Gaussian_2(x, x_i, h) * (1 - S_1(x, x_i, h) / S_2(x, x_i, h) *\n                                          (x - x_i))\n  return(a)\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- derivative_a() ---------------------------------#\nderivate_a <- function(center, sample_points, brand_width){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- sample_points\n  der_a <- 1 / h * derivate_Gaussian_2(x, x_i, h) *\n    (1 - S_1(x , x_i, h) / S_2(x, x_i, h) * (x - x_i))\n  + 1 / h * Gaussian_2(x, x_i, h) * (- derivate_S1(x, x_i, h) / S_2(x, x_i, h)\n                                     + S_1(x, x_i, h) / (S_2(x, x_i, h)^2)\n                                     * derivate_S2(x, x_i, h) * (x - x_i)\n                                     - S_1(x, x_i, h)/ S_2(x, x_i, h))\n}\n#-----------------------------------------------------------------------#\n\n#---------------------- The derivate of S ------------------------------#\nS_derivate <- function(center, sample_points, brand_width, response){\n  h <- brand_width\n  x <- as.vector(center)\n  x_i <- sample_points\n  y <- response\n  a <- a(x, x_i, h)\n  der_S <- (sum(derivate_a(x, x_i, h) * y) * sum(a) - sum(a * y) *\n              sum(derivate_a(x, x_i, h))) / sum(a ^ 2)\n  return(der_S)\n}\n#-----------------------------------------------------------------------#\n\n#***********************************************************************#\n\n#************* Step 5: Estimating the projection direction *************#\n\n#---------------- function : find the new projection direction ---------#\nnew_projected_dir <- function(residuals, design_matrix, old_projected_dir,\n                              np_model){\n  res <- residuals\n  design_matrix <- design_matrix\n  dir_old <- old_projected_dir\n  res_pred <- predict(np_model, # the np_model is fixed\n                      newdata = as.data.frame(design_matrix %*% dir_old))\n  h <- np_model$bw # np_model gives the band width automatically\n  res_pred_der <- matrix(rep(0, nrow(design_matrix)), ncol = 1)\n  for(i in 1:nrow(design_matrix)){\n    res_pred_der[i, 1] <- S_derivate(design_matrix[i, ] %*% dir_old,\n                                     design_matrix %*% dir_old, h, res) #key point\n  }\n  weight_reg_response <- design_matrix %*% as.matrix(dir_old) +\n    (res - res_pred)/res_pred_der\n  weight <- (res_pred_der) ^ 2\n\n  design_matrix <- design_matrix\n\n  weight_lm_model <- lm(weight_reg_response ~ 0 + design_matrix, weights = weight)\n\n  dir_new <- matrix(unname(weight_lm_model$coefficients), ncol = 1)\n  return(dir_new)\n}\n#----------------------------------------------------------------------#\n\n#**********************************************************************#\n\n#************** Step 6: iterating the direction to converge ***********#\n\n#----------- inf_norm: measure the distance between two vectors -------#\ninf_norm <- function(vec_1, vec_2){\n  max_elem <- max(abs(vec_1 - vec_2))\n  return(max_elem)\n}\n#----------------------------------------------------------------------#\n\n#---- projection_dir_final function: converge the projection_dir ------#\nprojection_dir_final <- function(residuals, design_matrix,\n                                 initial_projected_dir, epslon){\n  res <- residuals\n  old_dir <- initial_projected_dir\n  S <- S(old_dir, res, design_matrix)\n  new_dir <- new_projected_dir(res, design_matrix, old_dir, S)\n  while(inf_norm(old_dir, new_dir) > epslon){\n    old_dir <- new_dir\n    new_dir <- new_projected_dir(res, design_matrix, old_dir, S)\n  }\n  return(new_dir)\n}\n#----------------------------------------------------------------------#\n\n#**********************************************************************#\n\n#*** step 7: increasing terms to fit data from Computer Experiments ***#\n\n#---- PPR_CE: build a final PPR model for computer experiments --------#\n#----------------------------------------------------------------------#\nPPR_CE <- function(response, design_matrix, max_terms, method = \"ll\",\n                   epslon, required_accuracy){\n  Y <- response\n  design_matrix <- design_matrix\n  epslon <- epslon\n  max_terms <- max_terms\n  accuracy <- required_accuracy\n  res <- Y # add the 1st term\n  dir_old <- matrix(runif(ncol(design_matrix)), ncol = 1)\n  direction <- projection_dir_final(res, design_matrix, dir_old, epslon)\n  S <- S(dir_old, res, design_matrix)\n  res_pred <- predict(S, # the np_model is fixed\n                      newdata = as.data.frame(design_matrix %*% direction))\n  model_list <- list()\n  model_term <- 1 # the number of model terms\n  model_list[[1]] <- list(model = S, direction = direction)\n  while(inf_norm(res_pred, res) > accuracy ){\n    res <- Y - res_pred # add the 1st term\n    dir_old <- matrix(runif(ncol(design_matrix)), ncol = 1)\n    direction <- projection_dir_final(res, design_matrix, dir_old, epslon)\n    S <- S(dir_old, res, design_matrix)\n    res_pred <- predict(S, # the np_model is fixed\n                        newdata = as.data.frame(design_matrix %*% direction))\n    model_term <- model_term + 1\n    model_list[[model_terms]] <- list(model = S, direction = direction)\n  }\n\n  return(model_list)\n}\n#----------------------------------------------------------------------#\n\n#**********************************************************************#\n\n\n\n\n\n",
    "created" : 1461543956762.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4253320810",
    "id" : "FC54554A",
    "lastKnownWriteTime" : 1461573865,
    "last_content_update" : 1461573865188,
    "path" : "~/R/R Codes/Project_PPInterpolator/PPInterpolator/R/ppr_soucecode.R",
    "project_path" : "R/ppr_soucecode.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}